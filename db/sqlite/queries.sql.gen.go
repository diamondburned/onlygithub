// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: queries.sql

package sqlite

import (
	"context"
	"database/sql"
	"time"
)

const imageAsset = `-- name: ImageAsset :one
SELECT id, type, data, visibility, minimum_cost, last_updated FROM assets WHERE id = ? AND type = 'image'
`

func (q *Queries) ImageAsset(ctx context.Context, id string) (Asset, error) {
	row := q.db.QueryRowContext(ctx, imageAsset, id)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Data,
		&i.Visibility,
		&i.MinimumCost,
		&i.LastUpdated,
	)
	return i, err
}

const postAsset = `-- name: PostAsset :one
SELECT id, type, data, visibility, minimum_cost, last_updated FROM assets WHERE id = ? AND type = 'post'
`

func (q *Queries) PostAsset(ctx context.Context, id string) (Asset, error) {
	row := q.db.QueryRowContext(ctx, postAsset, id)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Data,
		&i.Visibility,
		&i.MinimumCost,
		&i.LastUpdated,
	)
	return i, err
}

const restoreToken = `-- name: RestoreToken :one
SELECT token, provider, access_token, token_type, refresh_token, expires_in, created FROM oauth_tokens WHERE token = ? AND provider = ?
`

type RestoreTokenParams struct {
	Token    string
	Provider string
}

func (q *Queries) RestoreToken(ctx context.Context, arg RestoreTokenParams) (OauthToken, error) {
	row := q.db.QueryRowContext(ctx, restoreToken, arg.Token, arg.Provider)
	var i OauthToken
	err := row.Scan(
		&i.Token,
		&i.Provider,
		&i.AccessToken,
		&i.TokenType,
		&i.RefreshToken,
		&i.ExpiresIn,
		&i.Created,
	)
	return i, err
}

const saveToken = `-- name: SaveToken :exec
INSERT INTO oauth_tokens (token, provider, access_token, token_type, refresh_token, expires_in)
	VALUES (?, ?, ?, ?, ?, ?)
`

type SaveTokenParams struct {
	Token        string
	Provider     string
	AccessToken  string
	TokenType    string
	RefreshToken string
	ExpiresIn    time.Time
}

func (q *Queries) SaveToken(ctx context.Context, arg SaveTokenParams) error {
	_, err := q.db.ExecContext(ctx, saveToken,
		arg.Token,
		arg.Provider,
		arg.AccessToken,
		arg.TokenType,
		arg.RefreshToken,
		arg.ExpiresIn,
	)
	return err
}

const setTier = `-- name: SetTier :exec
REPLACE INTO tiers (id, name, price, description)
	VALUES (?, ?, ?, ?)
`

type SetTierParams struct {
	ID          string
	Name        string
	Price       int64
	Description sql.NullString
}

func (q *Queries) SetTier(ctx context.Context, arg SetTierParams) error {
	_, err := q.db.ExecContext(ctx, setTier,
		arg.ID,
		arg.Name,
		arg.Price,
		arg.Description,
	)
	return err
}

const setUser = `-- name: SetUser :exec
REPLACE INTO users (id, name, email, nickname)
	VALUES (?, ?, ?, ?)
`

type SetUserParams struct {
	ID       string
	Name     string
	Email    sql.NullString
	Nickname sql.NullString
}

func (q *Queries) SetUser(ctx context.Context, arg SetUserParams) error {
	_, err := q.db.ExecContext(ctx, setUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Nickname,
	)
	return err
}

const setUserTier = `-- name: SetUserTier :exec
REPLACE INTO user_tiers (user_id, tier_id, price, is_one_time, is_custom_amount)
	VALUES (?, ?, ?, ?, ?)
`

type SetUserTierParams struct {
	UserID         string
	TierID         sql.NullString
	Price          int64
	IsOneTime      bool
	IsCustomAmount bool
}

func (q *Queries) SetUserTier(ctx context.Context, arg SetUserTierParams) error {
	_, err := q.db.ExecContext(ctx, setUserTier,
		arg.UserID,
		arg.TierID,
		arg.Price,
		arg.IsOneTime,
		arg.IsCustomAmount,
	)
	return err
}

const user = `-- name: User :one
SELECT id, name, email, nickname, avatar_url, joined_at FROM users WHERE id = ?
`

func (q *Queries) User(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, user, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Nickname,
		&i.AvatarUrl,
		&i.JoinedAt,
	)
	return i, err
}
