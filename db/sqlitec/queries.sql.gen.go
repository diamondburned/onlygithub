// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: queries.sql

package sqlitec

import (
	"context"
	"database/sql"
	"time"
)

const bindAssetToPost = `-- name: BindAssetToPost :exec
INSERT INTO asset_refs (post_id, asset_id) VALUES (?, ?)
`

type BindAssetToPostParams struct {
	PostID  sql.NullString
	AssetID string
}

func (q *Queries) BindAssetToPost(ctx context.Context, arg BindAssetToPostParams) error {
	_, err := q.db.ExecContext(ctx, bindAssetToPost, arg.PostID, arg.AssetID)
	return err
}

const createImageAsset = `-- name: CreateImageAsset :one
INSERT INTO assets (id, data, filename, preview_url, width, height, visibility, minimum_cost, last_updated)
	VALUES (?, ?, ?, ?, ?, ?, ?, ?, datetime())
	RETURNING last_updated
`

type CreateImageAssetParams struct {
	ID          string
	Data        []byte
	Filename    string
	PreviewUrl  sql.NullString
	Width       int64
	Height      int64
	Visibility  string
	MinimumCost int64
}

func (q *Queries) CreateImageAsset(ctx context.Context, arg CreateImageAssetParams) (sql.NullTime, error) {
	row := q.db.QueryRowContext(ctx, createImageAsset,
		arg.ID,
		arg.Data,
		arg.Filename,
		arg.PreviewUrl,
		arg.Width,
		arg.Height,
		arg.Visibility,
		arg.MinimumCost,
	)
	var last_updated sql.NullTime
	err := row.Scan(&last_updated)
	return last_updated, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts (id, data, visibility, minimum_cost, last_updated)
	VALUES (?, ?, ?, ?, datetime())
	RETURNING last_updated
`

type CreatePostParams struct {
	ID          string
	Data        []byte
	Visibility  string
	MinimumCost int64
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (sql.NullTime, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.Data,
		arg.Visibility,
		arg.MinimumCost,
	)
	var last_updated sql.NullTime
	err := row.Scan(&last_updated)
	return last_updated, err
}

const createTier = `-- name: CreateTier :exec
INSERT INTO tiers (id, name, price, description)
	VALUES (?, ?, ?, ?)
`

type CreateTierParams struct {
	ID          string
	Name        string
	Price       int64
	Description string
}

func (q *Queries) CreateTier(ctx context.Context, arg CreateTierParams) error {
	_, err := q.db.ExecContext(ctx, createTier,
		arg.ID,
		arg.Name,
		arg.Price,
		arg.Description,
	)
	return err
}

const deleteAllTiers = `-- name: DeleteAllTiers :exec
DELETE FROM tiers
`

func (q *Queries) DeleteAllTiers(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllTiers)
	return err
}

const deleteImageAsset = `-- name: DeleteImageAsset :exec
DELETE FROM assets WHERE id = ?
`

func (q *Queries) DeleteImageAsset(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteImageAsset, id)
	return err
}

const deleteToken = `-- name: DeleteToken :exec
DELETE FROM oauth_tokens WHERE token = ? AND provider = ?
`

type DeleteTokenParams struct {
	Token    string
	Provider string
}

func (q *Queries) DeleteToken(ctx context.Context, arg DeleteTokenParams) error {
	_, err := q.db.ExecContext(ctx, deleteToken, arg.Token, arg.Provider)
	return err
}

const deleteUserTier = `-- name: DeleteUserTier :exec
DELETE FROM user_tiers WHERE user_id = ?
`

func (q *Queries) DeleteUserTier(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, deleteUserTier, userID)
	return err
}

const imageAsset = `-- name: ImageAsset :one
SELECT filename, visibility, minimum_cost, last_updated FROM assets WHERE id = ?
`

type ImageAssetRow struct {
	Filename    string
	Visibility  string
	MinimumCost int64
	LastUpdated sql.NullTime
}

func (q *Queries) ImageAsset(ctx context.Context, id string) (ImageAssetRow, error) {
	row := q.db.QueryRowContext(ctx, imageAsset, id)
	var i ImageAssetRow
	err := row.Scan(
		&i.Filename,
		&i.Visibility,
		&i.MinimumCost,
		&i.LastUpdated,
	)
	return i, err
}

const imageData = `-- name: ImageData :one
SELECT data FROM assets WHERE id = ?
`

func (q *Queries) ImageData(ctx context.Context, id string) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, imageData, id)
	var data []byte
	err := row.Scan(&data)
	return data, err
}

const makeOwner = `-- name: MakeOwner :exec
UPDATE users SET is_owner = TRUE WHERE username = ?
`

func (q *Queries) MakeOwner(ctx context.Context, username string) error {
	_, err := q.db.ExecContext(ctx, makeOwner, username)
	return err
}

const owner = `-- name: Owner :one

SELECT id, username, email, real_name, pronouns, avatar_url, joined_at, is_owner, user_config, site_config FROM users WHERE is_owner = TRUE
`

// omitted: User :one
func (q *Queries) Owner(ctx context.Context) (User, error) {
	row := q.db.QueryRowContext(ctx, owner)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.RealName,
		&i.Pronouns,
		&i.AvatarUrl,
		&i.JoinedAt,
		&i.IsOwner,
		&i.UserConfig,
		&i.SiteConfig,
	)
	return i, err
}

const pinAssetRef = `-- name: PinAssetRef :exec
REPLACE INTO asset_refs (post_id, asset_id) VALUES (NULL, ?)
`

func (q *Queries) PinAssetRef(ctx context.Context, assetID string) error {
	_, err := q.db.ExecContext(ctx, pinAssetRef, assetID)
	return err
}

const post = `-- name: Post :one
SELECT id, data, visibility, minimum_cost, last_updated FROM posts WHERE id = ?
`

func (q *Queries) Post(ctx context.Context, id string) (Post, error) {
	row := q.db.QueryRowContext(ctx, post, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Data,
		&i.Visibility,
		&i.MinimumCost,
		&i.LastUpdated,
	)
	return i, err
}

const postImages = `-- name: PostImages :many
SELECT assets.id, assets.preview_url, assets.width, assets.height
	FROM asset_refs
	INNER JOIN assets ON assets.id = asset_refs.asset_id
	WHERE asset_refs.post_id = ?
`

type PostImagesRow struct {
	ID         string
	PreviewUrl sql.NullString
	Width      int64
	Height     int64
}

func (q *Queries) PostImages(ctx context.Context, postID sql.NullString) ([]PostImagesRow, error) {
	rows, err := q.db.QueryContext(ctx, postImages, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PostImagesRow
	for rows.Next() {
		var i PostImagesRow
		if err := rows.Scan(
			&i.ID,
			&i.PreviewUrl,
			&i.Width,
			&i.Height,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const posts = `-- name: Posts :many
SELECT id, data, visibility, minimum_cost, last_updated FROM posts ORDER BY id LIMIT 15
`

func (q *Queries) Posts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, posts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Data,
			&i.Visibility,
			&i.MinimumCost,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postsBefore = `-- name: PostsBefore :many
SELECT id, data, visibility, minimum_cost, last_updated FROM posts WHERE id < ? ORDER BY id LIMIT 15
`

func (q *Queries) PostsBefore(ctx context.Context, id string) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, postsBefore, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Data,
			&i.Visibility,
			&i.MinimumCost,
			&i.LastUpdated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreToken = `-- name: RestoreToken :one
SELECT token, provider, access_token, token_type, refresh_token, expires_in, created FROM oauth_tokens WHERE token = ? AND provider = ?
`

type RestoreTokenParams struct {
	Token    string
	Provider string
}

func (q *Queries) RestoreToken(ctx context.Context, arg RestoreTokenParams) (OauthToken, error) {
	row := q.db.QueryRowContext(ctx, restoreToken, arg.Token, arg.Provider)
	var i OauthToken
	err := row.Scan(
		&i.Token,
		&i.Provider,
		&i.AccessToken,
		&i.TokenType,
		&i.RefreshToken,
		&i.ExpiresIn,
		&i.Created,
	)
	return i, err
}

const saveToken = `-- name: SaveToken :exec
INSERT INTO oauth_tokens (token, provider, access_token, token_type, refresh_token, expires_in)
	VALUES (?, ?, ?, ?, ?, ?)
`

type SaveTokenParams struct {
	Token        string
	Provider     string
	AccessToken  string
	TokenType    string
	RefreshToken string
	ExpiresIn    time.Time
}

func (q *Queries) SaveToken(ctx context.Context, arg SaveTokenParams) error {
	_, err := q.db.ExecContext(ctx, saveToken,
		arg.Token,
		arg.Provider,
		arg.AccessToken,
		arg.TokenType,
		arg.RefreshToken,
		arg.ExpiresIn,
	)
	return err
}

const setAssetVisibility = `-- name: SetAssetVisibility :exec
UPDATE assets SET visibility = ? WHERE id = ?
`

type SetAssetVisibilityParams struct {
	Visibility string
	ID         string
}

func (q *Queries) SetAssetVisibility(ctx context.Context, arg SetAssetVisibilityParams) error {
	_, err := q.db.ExecContext(ctx, setAssetVisibility, arg.Visibility, arg.ID)
	return err
}

const setPostVisibility = `-- name: SetPostVisibility :exec
UPDATE posts SET visibility = ? WHERE id = ?
`

type SetPostVisibilityParams struct {
	Visibility string
	ID         string
}

func (q *Queries) SetPostVisibility(ctx context.Context, arg SetPostVisibilityParams) error {
	_, err := q.db.ExecContext(ctx, setPostVisibility, arg.Visibility, arg.ID)
	return err
}

const setSiteConfig = `-- name: SetSiteConfig :exec
UPDATE users SET site_config = ? WHERE is_owner = TRUE
`

func (q *Queries) SetSiteConfig(ctx context.Context, siteConfig []byte) error {
	_, err := q.db.ExecContext(ctx, setSiteConfig, siteConfig)
	return err
}

const setTier = `-- name: SetTier :exec
REPLACE INTO tiers (id, name, price, description)
	VALUES (?, ?, ?, ?)
`

type SetTierParams struct {
	ID          string
	Name        string
	Price       int64
	Description string
}

func (q *Queries) SetTier(ctx context.Context, arg SetTierParams) error {
	_, err := q.db.ExecContext(ctx, setTier,
		arg.ID,
		arg.Name,
		arg.Price,
		arg.Description,
	)
	return err
}

const setUserConfig = `-- name: SetUserConfig :exec
UPDATE users SET user_config = ? WHERE id = ?
`

type SetUserConfigParams struct {
	UserConfig []byte
	ID         string
}

func (q *Queries) SetUserConfig(ctx context.Context, arg SetUserConfigParams) error {
	_, err := q.db.ExecContext(ctx, setUserConfig, arg.UserConfig, arg.ID)
	return err
}

const setUserTier = `-- name: SetUserTier :exec
REPLACE INTO user_tiers (user_id, tier_id, price, is_one_time, is_custom_amount, started_at, renewed_at)
	VALUES (?, ?, ?, ?, ?, ?, ?)
`

type SetUserTierParams struct {
	UserID         string
	TierID         sql.NullString
	Price          int64
	IsOneTime      bool
	IsCustomAmount bool
	StartedAt      time.Time
	RenewedAt      time.Time
}

func (q *Queries) SetUserTier(ctx context.Context, arg SetUserTierParams) error {
	_, err := q.db.ExecContext(ctx, setUserTier,
		arg.UserID,
		arg.TierID,
		arg.Price,
		arg.IsOneTime,
		arg.IsCustomAmount,
		arg.StartedAt,
		arg.RenewedAt,
	)
	return err
}

const siteConfig = `-- name: SiteConfig :one
SELECT site_config FROM users WHERE is_owner = TRUE
`

func (q *Queries) SiteConfig(ctx context.Context) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, siteConfig)
	var site_config []byte
	err := row.Scan(&site_config)
	return site_config, err
}

const tiers = `-- name: Tiers :many
SELECT id, name, price, description FROM tiers
`

func (q *Queries) Tiers(ctx context.Context) ([]Tier, error) {
	rows, err := q.db.QueryContext(ctx, tiers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tier
	for rows.Next() {
		var i Tier
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :exec
INSERT INTO users (id, username, email, real_name, pronouns, avatar_url)
	VALUES (?, ?, ?, ?, ?, ?)
ON CONFLICT (id) DO UPDATE SET
	username = excluded.username,
	email = excluded.email,
	real_name = excluded.real_name,
	pronouns = excluded.pronouns,
	avatar_url = excluded.avatar_url
`

type UpdateUserParams struct {
	ID        string
	Username  string
	Email     string
	RealName  string
	Pronouns  string
	AvatarUrl string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.RealName,
		arg.Pronouns,
		arg.AvatarUrl,
	)
	return err
}

const userConfig = `-- name: UserConfig :one

SELECT user_config FROM users WHERE id = ?
`

// -- name: UnusedImageAssetIDs :many
// SELECT assets.id
// FROM ASSETS
// LEFT JOIN posts ON posts.image_asset_id = assets.id
// WHERE posts.id IS NULL AND assets.type = 'image';
func (q *Queries) UserConfig(ctx context.Context, id string) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, userConfig, id)
	var user_config []byte
	err := row.Scan(&user_config)
	return user_config, err
}
