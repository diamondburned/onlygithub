// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: queries.sql

package sqlitec

import (
	"context"
	"database/sql"
	"time"
)

const deleteUserTier = `-- name: DeleteUserTier :exec
DELETE FROM user_tiers WHERE user_id = ?
`

func (q *Queries) DeleteUserTier(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, deleteUserTier, userID)
	return err
}

const imageAsset = `-- name: ImageAsset :one
SELECT id, type, data, visibility, minimum_cost, last_updated FROM assets WHERE id = ? AND type = 'image'
`

func (q *Queries) ImageAsset(ctx context.Context, id string) (Asset, error) {
	row := q.db.QueryRowContext(ctx, imageAsset, id)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Data,
		&i.Visibility,
		&i.MinimumCost,
		&i.LastUpdated,
	)
	return i, err
}

const makeOwner = `-- name: MakeOwner :exec
UPDATE users SET is_owner = TRUE WHERE username = ?
`

func (q *Queries) MakeOwner(ctx context.Context, username string) error {
	_, err := q.db.ExecContext(ctx, makeOwner, username)
	return err
}

const owner = `-- name: Owner :one
SELECT id, username, email, real_name, pronouns, avatar_url, joined_at, is_owner, user_config, site_config FROM users WHERE is_owner = TRUE
`

func (q *Queries) Owner(ctx context.Context) (User, error) {
	row := q.db.QueryRowContext(ctx, owner)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.RealName,
		&i.Pronouns,
		&i.AvatarUrl,
		&i.JoinedAt,
		&i.IsOwner,
		&i.UserConfig,
		&i.SiteConfig,
	)
	return i, err
}

const postAsset = `-- name: PostAsset :one
SELECT id, type, data, visibility, minimum_cost, last_updated FROM assets WHERE id = ? AND type = 'post'
`

func (q *Queries) PostAsset(ctx context.Context, id string) (Asset, error) {
	row := q.db.QueryRowContext(ctx, postAsset, id)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Data,
		&i.Visibility,
		&i.MinimumCost,
		&i.LastUpdated,
	)
	return i, err
}

const restoreToken = `-- name: RestoreToken :one
SELECT token, provider, access_token, token_type, refresh_token, expires_in, created FROM oauth_tokens WHERE token = ? AND provider = ?
`

type RestoreTokenParams struct {
	Token    string
	Provider string
}

func (q *Queries) RestoreToken(ctx context.Context, arg RestoreTokenParams) (OauthToken, error) {
	row := q.db.QueryRowContext(ctx, restoreToken, arg.Token, arg.Provider)
	var i OauthToken
	err := row.Scan(
		&i.Token,
		&i.Provider,
		&i.AccessToken,
		&i.TokenType,
		&i.RefreshToken,
		&i.ExpiresIn,
		&i.Created,
	)
	return i, err
}

const saveToken = `-- name: SaveToken :exec
INSERT INTO oauth_tokens (token, provider, access_token, token_type, refresh_token, expires_in)
	VALUES (?, ?, ?, ?, ?, ?)
`

type SaveTokenParams struct {
	Token        string
	Provider     string
	AccessToken  string
	TokenType    string
	RefreshToken string
	ExpiresIn    time.Time
}

func (q *Queries) SaveToken(ctx context.Context, arg SaveTokenParams) error {
	_, err := q.db.ExecContext(ctx, saveToken,
		arg.Token,
		arg.Provider,
		arg.AccessToken,
		arg.TokenType,
		arg.RefreshToken,
		arg.ExpiresIn,
	)
	return err
}

const setSiteConfig = `-- name: SetSiteConfig :exec
UPDATE users SET site_config = ? WHERE is_owner = TRUE
`

func (q *Queries) SetSiteConfig(ctx context.Context, siteConfig []byte) error {
	_, err := q.db.ExecContext(ctx, setSiteConfig, siteConfig)
	return err
}

const setTier = `-- name: SetTier :exec
REPLACE INTO tiers (id, name, price, description)
	VALUES (?, ?, ?, ?)
`

type SetTierParams struct {
	ID          string
	Name        string
	Price       int64
	Description string
}

func (q *Queries) SetTier(ctx context.Context, arg SetTierParams) error {
	_, err := q.db.ExecContext(ctx, setTier,
		arg.ID,
		arg.Name,
		arg.Price,
		arg.Description,
	)
	return err
}

const setUserConfig = `-- name: SetUserConfig :exec
UPDATE users SET user_config = ? WHERE id = ?
`

type SetUserConfigParams struct {
	UserConfig []byte
	ID         string
}

func (q *Queries) SetUserConfig(ctx context.Context, arg SetUserConfigParams) error {
	_, err := q.db.ExecContext(ctx, setUserConfig, arg.UserConfig, arg.ID)
	return err
}

const setUserTier = `-- name: SetUserTier :exec
REPLACE INTO user_tiers (user_id, tier_id, price, is_one_time, is_custom_amount)
	VALUES (?, ?, ?, ?, ?)
`

type SetUserTierParams struct {
	UserID         string
	TierID         sql.NullString
	Price          int64
	IsOneTime      bool
	IsCustomAmount bool
}

func (q *Queries) SetUserTier(ctx context.Context, arg SetUserTierParams) error {
	_, err := q.db.ExecContext(ctx, setUserTier,
		arg.UserID,
		arg.TierID,
		arg.Price,
		arg.IsOneTime,
		arg.IsCustomAmount,
	)
	return err
}

const siteConfig = `-- name: SiteConfig :one
SELECT site_config FROM users WHERE is_owner = TRUE
`

func (q *Queries) SiteConfig(ctx context.Context) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, siteConfig)
	var site_config []byte
	err := row.Scan(&site_config)
	return site_config, err
}

const updateUser = `-- name: UpdateUser :exec
INSERT INTO users (id, username, email, real_name, pronouns, avatar_url)
	VALUES (?, ?, ?, ?, ?, ?)
ON CONFLICT (id) DO UPDATE SET
	username = excluded.username,
	email = excluded.email,
	real_name = excluded.real_name,
	pronouns = excluded.pronouns,
	avatar_url = excluded.avatar_url
`

type UpdateUserParams struct {
	ID        string
	Username  string
	Email     string
	RealName  string
	Pronouns  string
	AvatarUrl string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.RealName,
		arg.Pronouns,
		arg.AvatarUrl,
	)
	return err
}

const user = `-- name: User :one
SELECT
	users.id, users.username, users.email, users.real_name, users.pronouns, users.avatar_url, users.joined_at,
	user_tiers.price AS tier_price,
	user_tiers.is_one_time AS tier_is_one_time,
	user_tiers.is_custom_amount AS tier_is_custom_amount,
	user_tiers.started_at AS tier_started_at,
	user_tiers.renewed_at AS tier_renewed_at,
	tiers.id AS tier_id,
	tiers.name AS tier_name,
	tiers.description AS tier_description
FROM users AS users -- https://github.com/kyleconroy/sqlc/issues/2271
LEFT JOIN user_tiers ON users.id = user_tiers.user_id
LEFT JOIN tiers ON user_tiers.tier_id = tiers.id
WHERE users.id = ?
`

type UserRow struct {
	ID                 string
	Username           string
	Email              string
	RealName           string
	Pronouns           string
	AvatarUrl          string
	JoinedAt           time.Time
	TierPrice          int64
	TierIsOneTime      bool
	TierIsCustomAmount bool
	TierStartedAt      time.Time
	TierRenewedAt      time.Time
	TierID             string
	TierName           string
	TierDescription    string
}

func (q *Queries) User(ctx context.Context, id string) (UserRow, error) {
	row := q.db.QueryRowContext(ctx, user, id)
	var i UserRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.RealName,
		&i.Pronouns,
		&i.AvatarUrl,
		&i.JoinedAt,
		&i.TierPrice,
		&i.TierIsOneTime,
		&i.TierIsCustomAmount,
		&i.TierStartedAt,
		&i.TierRenewedAt,
		&i.TierID,
		&i.TierName,
		&i.TierDescription,
	)
	return i, err
}

const userConfig = `-- name: UserConfig :one
SELECT user_config FROM users WHERE id = ?
`

func (q *Queries) UserConfig(ctx context.Context, id string) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, userConfig, id)
	var user_config []byte
	err := row.Scan(&user_config)
	return user_config, err
}
